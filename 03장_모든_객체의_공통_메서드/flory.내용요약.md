# 3장. 모든 객체의 공통 메서드

## ✨ 아이템10. equals는 일반 규약을 지켜 재정의하라.

#### ✔️ equals를 재정의하지 않아야 할때.
+ 각 인스턴스가 본질적으로 고유할 때.  
+ 인스턴스의 '논리적 동치성'을 검사할 일이 없을 때.  
+ 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞을때.   
+ 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없을 때.

#### ✔️ equals 메서드를 재정의해야 할 때.
+ 객체 식별성이 아니라 논리적 동치성을 확인

#### ✔️ equals 메서드를 재정의할 때, Object 명세에 적힌 규약을 따라야한다.
1️⃣ 반사성: null이 아닌 모든 참조값 x에 대해, x.equals(x)는 true 이다.  
2️⃣ 대칭성 : null이 아닌 모든 참조값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true 이다.  
3️⃣ 추이성 : null이 아닌 모든 참조값 x,y,z에 대해, x.equals(y)가 true이고 y.equals(z)도 true면, x.equals(z)도 true이다.  
4️⃣ 일관성 : null이 아닌 모든 참조값 x,y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.  
5️⃣ null-아님 : null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false 이다.

#### ✔️ equals 메서드 구현 방법
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을  올바른 타입으로 형변환한다.
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.


## ✨ 아이템11. equals를 재정의하려거든 hashCode도 재정의하라.
> equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다.  
> 재정의한 hashCode는 Object의 API 문서에 기술된 아래의 일반 규약을 따라야 한다. 또한, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다.

1️⃣ equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.  
단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.  
2️⃣ equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.   
3️⃣ equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.


## ✨ 아이템12. toString을 항상 재정의하라.
> 상위 클래스에서 이미 알맞게 재정의한 경우를 제외하고 모든 구체 클래스에서 Object의 toString을 재정의하자. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.
+ toString 클래스를 사용한 시스템은 디버깅하기 쉽다.
+ 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.
+ toString을 사용하는 이유는  @sdaklfdsjfladslkfj 이렇게 16진수로 표시한 해시코드를 우리가 알아볼 수 있도록 수정해주기 때문이다.

## ✨ 아이템13. clone 재정의는 주의해서 진행하라.
> Cloneable은 복제해도 되는 클래스임을 명시하는 용도지만 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안되는 등 여러 문제점이 있다.   
> 하지만 Cloneable 방식은 널리 쓰이고 있어서 잘 알아두는 것이 좋다. 그 중, 배열은 clone 메서드 방식이 가장 깔끔하다.
+ clone 메서드는 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
+ public인 clone 메서드에서는 throws 절을 없애야 한다.

## ✨ 아이템14. Comparable을 구현할지 고려하라.
> Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서가 있음을 뜻한다. 알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.  
> 모든 객체에 대해 전역 동치관계를 부여하는 equals 메서드와 달리, compareTo는 타입이 다른 객체를 신경 쓰지 않아도 된다. 타입이 다른 객체가 주어지면 간단히 ClassCastException을 던져도 된다.
#### ✔️ compareTo 규약
1️⃣ 두 객체 참조의 순서를 바꿔 비교해도 예상한 결과가 나와야 한다. (즉, 첫번째 객체가 두번째 객체보다 작으면 두번째가 첫번째보다 커야 한다.)  
2️⃣ 첫번째가 두번째보다 크고 두번째가 세번째보다 크면, 첫번째는 세번째보다 커야 한다.    
3️⃣ 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.