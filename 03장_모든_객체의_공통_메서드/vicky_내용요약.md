# 3장. 모든 객체의 공통 메서드


## 아이템 10. equals는 일반 규약을 지켜 재정의하라.

### 재정의를 피해야 하는 경우
1. 각 인스턴스가 본질적으로 고유하다.
    + 동작하는 객체를 표현하는 클래스. 예) Thread
2. 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
   + Patterns를 이용한 논리적 동치성
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 들어맞는다.
4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
    ```java
    // equals 호출방지
    @Override public boolean equals(Object o){
      throw new AssertionError();
    }
    ```

### 논리적 동치성 파악을 위한 equals 재정의
+ Map 키와 Set의 원소로 사용할 수 있다.
+ 인스턴스 통제 클래스라면 재정의 불필요
+ equals 동치관계를 지켜서 재정의하자.
   + 반사성, 대칭성, 추이성, 일관성, null-아님
> 한 클래스의 인스턴스는 다른 곳으로 빈번히 전달된다.
##### 대칭성
```java
@Override public boolean equals(Object o){
  return o instanceof CaseInsitiveString &&
    ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```
+ 이 경우에서 CaseInsitiveString의 존재를 모르는 String equals로 인해 동치성이 성립하지 못한다.
##### 추이성
+ 첫 번째와 두 번째가 같고, 두 번째 객체와 세 번째 객체가 같으면, 첫 번째와 세 번째 객체도 같아야 한다는 뜻이다.
+ 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
+ 리스코프 치환원칙
    + 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다.
+ Timestamp의 equals는 대칭성을 위배, Date와 사용하는 경우 주의
##### 일관성
+ 반복 호출시에도 동일한 결과 값을 가져야 한다.
+ java.net.URL equals는 주어진 URL과 매핑된 호스트 IP 주소로 비교하는데, 네트워크를 통하므로 항상 결과값이 같다고 할 수 없다.
    + equals는 항시 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행해야 한다.
##### null 아님
+ null 여부를 미리 확인해 NullPointerException 방지
+ 인스턴스 연산자가 올바른 매개변수 타입인지 확인하고 형변환

### equals 메서드 구현방법
+ 연산자를 사용해 입력이 자기 자신의 참조인지 확인
+ instanceof 연산자로 입력이 올바른 타입인지 확인
+ 입력을 올바른 타입으로 형변환
+ 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사

> + equals를 재정의할 땐 hashCode도 반드시 재정의하자
> + 너무 복잡하게 해결하려 들지 말자.
> + Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자. 반드시 매개타입은 Object o! 다중정의를 피할 것.


+ AutoValue 프레임워크


## 아이템 11. equals를 정의하려거든 hashCode도 재정의하라

### Object 명세규약
+ equals 비교에 사용되는 정보가 변경되지 않았다면, hashCode 메소드는 몇번을 호출해도 항상 같은 값을 반환해야 한다. 단, 애플리케이션이 다시 시작할 시에는 이 값이 달라져도 상관 없다. 
+ equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
    + HashMap은 해시코드가 다른 엔트리까지 동치성 비교를 시도조차 하지 않도록 최적화 되어 있다.
+ equals(Object)가 두 객체르 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 값에 대해서는 hashCode 역시 다른 값을 반환해야 해시 테이블 성능이 좋아진다.

<hr>

##### 모든 해시코드를 동일하게 반환 처리한다면?
+ 마치 연결리스트처럼 동작하게 되고 그 결과 평균 수행시간이 느려진다.
+ 그리고 다른 인스턴스라면 다른 해시코드를 반환해야 이상적

##### 그렇다면, 권장되는 해시코드 작성요령은?
1. int 변수인 result를 선언한 후 값을 c로 초기화한다.
이 때, c는 해당 객체의 첫번째 핵심 필드를 단계 2.1 방식으로 계산한 해시코드이다.
여기서 핵심 필드는 아이템 10에서 equals 비교에 사용되는 필드를 말한다.
2. 해당 객체의 나머지 핵심 필드인 f 각각에 대해 다음 작업을 수행한다.
    1. 해당 필드의 해시코드 c 를 계산한다.
기본 타입 필드라면, Type.hashCode(f)를 수행한다. 여기서 Type은 해당 기본타입의 박싱 클래스다.
참조 타입 필드면서, 이 클래스의 equals 메소드가 이 필드의 equals를 재귀적으로 호출하여 비교한다면, 이 필드의 hashCode를 재귀적으로 호출한다.
필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다.
    2. 단계 2.1에서 계산한 해시코드 c로 result를 갱신한다.
result = 31(소수) * result + c;
31이라는 숫자대신 짝수가 오게되면 해시 충돌이 자주 일어나게 된다.
31이라는 숫자를 사용하면 시프트 연산 및 뺄셈으로 대체해 최적화 할 수 있다.
31 * i 는 (i << 5) - i와 같다.
3. result를 반환한다. 
```java
@Override public int hashCode(){
  int result = Short.hashCode(areaCode);
  result = 31*result+Short.hashCode(prefix);
  result = 31*result+Short.hashCode(lineNum);
  return result;
}
```
<br>

##### 검증
+ 단위테스트 구현
+ 파생필드는 해시코드에서 제외
+ equals 비교에 사용되지 않은 필드는 반드시 제외할 것

##### Object hash 메소드
+ 한 줄로 간단하게 hashcode를 얻을 수 있으나 성능이 좋지 않다. 

<hr>

### 캐싱 활용하기
+ 클래스가 불변이고, hashcode 계산비용이 크다면 캐싱하는 방식을 고려하자
+ 객체가 주로 해시의 키로 사용될 것 같다면, 해시코드를 미리 계산해두거나
+ 키로 사용되지 않는다면, 지연 초기화 전략을 사용하자.
    + 이 때, 스레드 안전성을 고려하자.


+ AutoValue 프레임워크를 적용하자!

## 아이템 12. toString을 항상 재정의하라.

##### 모든 하위 클래스에서 이 메서드를 재정의하라!
+ 디버깅 시에도 진단에 필요한 충분한 정보를 제공할 수 있다.
+ 포멧 명시여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.
+ 정적 유틸리티 클래스는 toString을 제공할 이유가 없다.
+ 대부분의 열거타입에서는 완벽한 toString 기능을 제공한다.


+ AutoValue 프레임워크로 해결이 안되는 부분이 있다.

## 아이템 13. clone 재정의는 주의해서 진행하라.

### Cloneable 인터페이스
+ Object protected 메서드인 clone의 동작방식을 결정
+ 객체를 복사할지 CloneNotSupprotedException을 던질지 결정

##### Object clone 메소드의 일반 규약 - 허술하다
1. x.clone() != x 는 참이다. 원본 객체와 복사 객체는 서로 다른 객체이다.
2. x.clone().getClass() == x.getClass() 는 참이다. 하지만 반드시 만족해야 하는 것은 아니다.
3. x.clone().equals(x) 는 참이지만 필수는 아니다.
4. x.clone().getClass() == x.getClass(), super.clone()을 호출해 얻은 객체를 clone 메소드가 반환한다면, 이 식은 참이다. 관례상, 반환된 객체와 원본 객체는 독립적이어야 한다. 이를 만족하려면 super.clone으로 얻은 객체의 필드 중 하나 이상을 반환 전에 수정해야 할 수도 있다.

### 참조하는 객체의 가변성 여부
+ 불변객체를 참조하는 경우는 괜찮지만, 가변객체를 참조하는 경우, 복제된 인스턴스가 생성자를 통해 생성된 것이 아니므로 원본 인스턴스와 동일한 참조를 하게 되고, 버그가 발생할 수 있다.
+ 반환된 Stack 인스턴스의 size 필드는 올바른 값을 갖겠지만, elements 필드는 원본 Stack 인스턴스와 똑같은 배열을 참조할 것이다. 
    + 원본이나 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해친다는 이야기다.
+ 

## 아이템 14. Comparable을 구현할지 고려하라.

### compareTo