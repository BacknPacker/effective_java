# 아이템 26. 로 타입은 사용하지 말라.

### ❓ Raw Type(로 타입) 이란?
제너릭 타입에서 타입 매개변수를 전혀 사용하지 않는 것을 의미한다
- 예시로 `List<E>`는 raw type의 List이다.  
- `List<String>`과 같이 원소 타입을 명시해서 사용할 것을 권장한다.
  
### ❓ 왜 사용하지 말라는 걸까?

```java
public class RawType {
    public static void main(String[] args) {
        List rawType = new ArrayList();
        rawType.add("강원도");
        rawType.add(01012341234);

        for (Iterator i = rawType.iterator(); i.hasNext(); ) {
            // ClassCastException 발생
            String s = (String) i.next();
        }
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197964-0f628123-b121-4518-a9e5-f4771e8ce053.png)
> 컴파일 시점에서 잡는게 아닌 실제로 값을 가져와서 캐스팅 하는 시점에서 오류가 발생한다.  
> 오류는 발생 즉시 즉 컴파일시 발견해야 디버깅하는 관점에서도 편하기 때문이다.

```java
public static void main(String[] args) {
    List<String> parameterizedType = new ArrayList<>();

    parameterizedType.add("강원도");
    parameterizedType.add("강원도");
    parameterizedType.add(123123);

    for (String s : parameterizedType) {
        System.out.println(s);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197164-b23218f7-f4fb-4941-8b8c-5efb48b8af9c.png)
> 컴파일 과정에서 에러가 발생한다.  
> 컴파일 과정에서 오류가 발생하는 것과 컴파일 후에 발생하는 것은 엄청난 차이가 있다.

<hr/>

### ✅ 비한정적 와일드카드 타입
컬렉션의 원소 타입을 모를 때 혹은 컬렉션에 어떤 원소 타입이든 넣고 사용하고 싶을때 사용한다.
```java
// Set<E>에서 E가 들어갈 자리에 ?로 대체해주면 된다.
static int numElementsInCommon(Set<?> s1, Set<?> s2) {}
```

```java
public static void main(String[] args) {
    HashSet rawTypeSet = new HashSet();
    HashSet<?> wildCardSet = new HashSet<>();

    rawTypeSet.add("스트링타입");
    rawTypeSet.add(01012341234);

    wildCardSet.add("스트링타입"); // 컴파일 에러가 발생한다.
}
```
![image](https://user-images.githubusercontent.com/53300830/166201594-d4313499-aadb-4092-bea5-1f196e67e0c2.png)

> wildCardSet 컬렉션에 문자열에 어떤 타입을 넣던지간에 컴파일 에러가 발생한다.

#### ❓ 왜 사용하는걸까?
실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?` 로 대체할 수 있다.
```java
static void numElementsInCommon(HashSet<?> s1, HashSet<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s1.contains(s2)) result++;
    }
}
```
> 메서드 파라미터에 사용할 수 있으며, 이 메서드는 컬렉션이 어떤 타입이든지 인자로 받을 수 있다.  
> 그러므로 특정 파라미터에 맞게 일일이 메서드를 재정의할 필요가 없어진다.

# 아이템 27. 비검사 경고를 제거하라.

### ❓ 비검사 경고란?
오류는 아니지만 영역이 하이라이트 되면서 **개발자에게 경고**를 주는 것을 말한다.

![image](https://user-images.githubusercontent.com/53300830/166394604-05fdb2bc-b796-4dfa-b9dd-7ae936c8be6b.png)

> 가끔 알고리즘 풀다가 하는 실수 중 하나이다.

```java
public static void main(String[] args) {
    int[] arr= new int[100];
}
```
> 이렇게 비검사 경고도 전부 해결해주는 것이 좋다. -> 타입 안전성 보장 (타입 시스템 자체가 잘못 되지 않음을 보장한다.)

[타입 안전성이란?](https://tlonist-sang.github.io/Today-I-learned/jekyll/update/2020/09/29/typed-language.html)

### ✅ SuppressWarning("unchecked")
경고를 제거할 수 없는 상황이지만 타입이 확실하게 안전하다고 할 수 있을때 사용하는 어노테이션이다.
> 위 어노테이션을 사용할때는 항상 신중해야한다. 

```java
@SuppressWarnings("unchecked")
class ClassWarning {
    public Set<String> hello() {
        return new HashSet();
    }
}
```
> 왜 경고를 못없애고 @SuppressWarnings("unchecked") 를 사용했는지 주석으로 남겨야한다.

# 아이템 28. 배열보다는 리스트를 사용하라.
### ✅ 배열과 제네렉 타입의 차이점
- 배열
  + 공변이다.
  + Sub가 Super의 하위타입일 경우 Sub[]은 배열 Super[]의 하위타입이 된다.   
- 제네릭
  - 불공변이다.
  - 서로 다른 타입이 두 개 있을 때, List는 List의 하위타입도 아니고 상위 타입도 아니다.  
> 배열은 런타임 시점에 타입을 인지하고 실행합니다.(실체화), 제네릭은 런타임 시점에 타입 정보를 소거하게 됩니다.(erasure)  
> 왜냐하면 제네릭은 타입 시스템 자체가 컴파일 시점에 에러를 잡고 런타임에 ClassCastException이 발생하는 일을 막아주기 때문입니다.

#### ⛔️ 하지만 실제 코딩에서는 문제가 있다. 
![image](https://user-images.githubusercontent.com/53300830/166395991-1bf05b27-c9d5-47af-88a9-00ca7d63ddd0.png)

#### ❓ 그럼 제네릭 배열을 사용하는 것은 어떠한가?
제네릭 + 배열은 불가능하다. 우선 아래 예시 코드이다.
```java
new List<E>[]
new List<String>[]
new E[]
```
> 제네릭 배열이 만약 허용된다면 런타임이 ClassCastException 을 방지해준다는 장점이 사라진다.
[궁금증](https://github.com/BacknPacker/effective_java/issues/29)

<hr/>

### ✅ 실체화 불가 타입(non-reifiable type)
실체화가 되지 않아서 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입을 뜻한다.  
예) 정규 타입 매개변수 `E` / 제네릭 타입 `List<E>` / 매개변수 타입 `List<String>`

### ✅ 비검사 형변환 경고를 제거하기 위해 배열 대신 리스트 사용
리스트 기반 Chooser를 통한 타입 안전성 확보
> 성능상 조금 느려지지만, 런타임시에 ClassCastException을 만날 일이 사라진다.
```java
public class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        choiceList = new ArrayList<>(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size));
    }
}
```

### ❓ 왜 배열보다 리스트일까?
아주 간단한 이유입니다. 지금까지 ~대신 ~사용하라 일 때마다 기본적으로 후자가 더 안전하기 때문입니다.  
추가적으로 런타임이 아닌 컴파일 시점에 에러를 잡아주기 때문입니다.




