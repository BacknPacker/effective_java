# 아이템 26. 로 타입은 사용하지 말라.

### ❓ Raw Type(로 타입) 이란?
제너릭 타입에서 타입 매개변수를 전혀 사용하지 않는 것을 의미한다
- 예시로 `List<E>`는 raw type의 List이다.  
- `List<String>`과 같이 원소 타입을 명시해서 사용할 것을 권장한다.
  
### ❓ 왜 사용하지 말라는 걸까?

```java
public class RawType {
    public static void main(String[] args) {
        List rawType = new ArrayList();
        rawType.add("강원도");
        rawType.add(01012341234);

        for (Iterator i = rawType.iterator(); i.hasNext(); ) {
            // ClassCastException 발생
            String s = (String) i.next();
        }
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197964-0f628123-b121-4518-a9e5-f4771e8ce053.png)
> 컴파일 시점에서 잡는게 아닌 실제로 값을 가져와서 캐스팅 하는 시점에서 오류가 발생한다.  
> 오류는 발생 즉시 즉 컴파일시 발견해야 디버깅하는 관점에서도 편하기 때문이다.

```java
public static void main(String[] args) {
    List<String> parameterizedType = new ArrayList<>();

    parameterizedType.add("강원도");
    parameterizedType.add("강원도");
    parameterizedType.add(123123);

    for (String s : parameterizedType) {
        System.out.println(s);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197164-b23218f7-f4fb-4941-8b8c-5efb48b8af9c.png)
> 컴파일 과정에서 에러가 발생한다.  
> 컴파일 과정에서 오류가 발생하는 것과 컴파일 후에 발생하는 것은 엄청난 차이가 있다.

<hr/>

### ✅ 비한정적 와일드카드 타입
컬렉션의 원소 타입을 모를 때 혹은 컬렉션에 어떤 원소 타입이든 넣고 사용하고 싶을때 사용한다.
```java
// Set<E>에서 E가 들어갈 자리에 ?로 대체해주면 된다.
static int numElementsInCommon(Set<?> s1, Set<?> s2) {}
```

```java
public static void main(String[] args) {
    HashSet rawTypeSet = new HashSet();
    HashSet<?> wildCardSet = new HashSet<>();

    rawTypeSet.add("스트링타입");
    rawTypeSet.add(01012341234);

    wildCardSet.add("스트링타입"); // 컴파일 에러가 발생한다.
}
```
![image](https://user-images.githubusercontent.com/53300830/166201594-d4313499-aadb-4092-bea5-1f196e67e0c2.png)

> wildCardSet 컬렉션에 문자열에 어떤 타입을 넣던지간에 컴파일 에러가 발생한다.

#### ❓ 왜 사용하는걸까?
실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?` 로 대체할 수 있다.
```java
static void numElementsInCommon(HashSet<?> s1, HashSet<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s1.contains(s2)) result++;
    }
}
```
> 메서드 파라미터에 사용할 수 있으며, 이 메서드는 컬렉션이 어떤 타입이든지 인자로 받을 수 있다.  
> 그러므로 특정 파라미터에 맞게 일일이 메서드를 재정의할 필요가 없어진다.

# 아이템 27. 비검사 경고를 제거하라.

### ❓ 비검사 경고란?
오류는 아니지만 영역이 하이라이트 되면서 **개발자에게 경고**를 주는 것을 말한다.

![image](https://user-images.githubusercontent.com/53300830/166394604-05fdb2bc-b796-4dfa-b9dd-7ae936c8be6b.png)

> 가끔 알고리즘 풀다가 하는 실수 중 하나이다.

```java
public static void main(String[] args) {
    int[] arr= new int[100];
}
```
> 이렇게 비검사 경고도 전부 해결해주는 것이 좋다. -> 타입 안전성 보장 (타입 시스템 자체가 잘못 되지 않음을 보장한다.)

[타입 안전성이란?](https://tlonist-sang.github.io/Today-I-learned/jekyll/update/2020/09/29/typed-language.html)

### ✅ SuppressWarning("unchecked")
경고를 제거할 수 없는 상황이지만 타입이 확실하게 안전하다고 할 수 있을때 사용하는 어노테이션이다.
> 위 어노테이션을 사용할때는 항상 신중해야한다. 

```java
@SuppressWarnings("unchecked")
class ClassWarning {
    public Set<String> hello() {
        return new HashSet();
    }
}
```
> 왜 경고를 못없애고 @SuppressWarnings("unchecked") 를 사용했는지 주석으로 남겨야한다.

# 아이템 28. 배열보다는 리스트를 사용하라.
### ✅ 배열과 제네렉 타입의 차이점
- 배열
  + 공변이다.
  + Sub가 Super의 하위타입일 경우 Sub[]은 배열 Super[]의 하위타입이 된다.   
- 제네릭
  - 불공변이다.
  - 서로 다른 타입이 두 개 있을 때, List는 List의 하위타입도 아니고 상위 타입도 아니다.  
> 배열은 런타임 시점에 타입을 인지하고 실행합니다.(실체화), 제네릭은 런타임 시점에 타입 정보를 소거하게 됩니다.(erasure)  
> 왜냐하면 제네릭은 타입 시스템 자체가 컴파일 시점에 에러를 잡고 런타임에 ClassCastException이 발생하는 일을 막아주기 때문입니다.

#### ⛔️ 하지만 실제 코딩에서는 문제가 있다. 
![image](https://user-images.githubusercontent.com/53300830/166395991-1bf05b27-c9d5-47af-88a9-00ca7d63ddd0.png)

#### ❓ 그럼 제네릭 배열을 사용하는 것은 어떠한가?
제네릭 + 배열은 불가능하다. 우선 아래 예시 코드이다.
```java
new List<E>[]
new List<String>[]
new E[]
```
> 제네릭 배열이 만약 허용된다면 런타임이 ClassCastException 을 방지해준다는 장점이 사라진다.
[궁금증](https://github.com/BacknPacker/effective_java/issues/29)

<hr/>

### ✅ 실체화 불가 타입(non-reifiable type)
실체화가 되지 않아서 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입을 뜻한다.  
예) 정규 타입 매개변수 `E` / 제네릭 타입 `List<E>` / 매개변수 타입 `List<String>`

### ✅ 비검사 형변환 경고를 제거하기 위해 배열 대신 리스트 사용
리스트 기반 Chooser를 통한 타입 안전성 확보
> 성능상 조금 느려지지만, 런타임시에 ClassCastException을 만날 일이 사라진다.
```java
public class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        choiceList = new ArrayList<>(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size));
    }
}
```

### ❓ 왜 배열보다 리스트일까?
> 아주 간단한 이유입니다. 지금까지 ~대신 ~사용하라 일 때마다 기본적으로 후자가 더 안전하기 때문입니다.    
> 추가적으로 런타임이 아닌 컴파일 시점에 에러를 잡아주기 때문입니다.

## 아이템 29. 이왕이면 제네릭 타입으로 만들어라.
> 이전 아이템에서 계속 이야기 했던 내용이다. 제네릭은 타입안전성을 보장하고, 형변환과 타입추론을 생략하게 해준다.

### ❓ 왜 제네릭 메서드로 바꿔야 할까? 그리고 어떻게 바꾸면 되는 것일까?
우선 아이템 7에서 했던 `Stack` 코드를 예시로 들 수 있다. Object 기반으로 작성됐으므로 제네릭을 사용하지 않은 상태이다. [참고 블로그](https://catsbi.oopy.io/83635cfe-1cab-43f2-a943-56a9efd83fb2#138a7431-32b1-4dc6-a6ea-ddc7c3b57776)

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    // 원소 추가
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    // 원소 제거 개선 코드
    public void pop() {
        if (size == 0) {
            new EmptyStackException();
            return;
        }
        Object element = elements[--size];
        elements[size] = null;
    }
    // 생략
}
```
> 컴파일시에는 문제가 없다. 그래도 제네릭으로 바꿔야 하는 이유는 명확하다. pop을 통해 꺼낸 객체를 계속 Object로 형변환 해줘야 하기때문이다.

```java
public class GenericStack<E> {
    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public GenericStack() {
        elements = new E[DEFAULT_INITIAL_CAPACITY]; 
        // 컴파일 오류 발생
        // java: generic array creation
    }

    // 원소 추가
    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    // 원소 제거 개선 코드
    public void pop() {
        if (size == 0) {
            new EmptyStackException();
            return;
        }
        E element = elements[--size];
        elements[size] = null;
    }
    // 생략
}
```
> 아이템 28을 생각해보면 알 수 있다. 제네릭 배열이기 때문에 불가능하다. 

### ✅ 해결 방법 1. Object 배열 생성한 뒤 제네릭으로 형변환하기
할 수는 있지만 타입이 안전하지 않다는 경고가 뜬다.

![image](https://user-images.githubusercontent.com/53300830/166614043-192f51a6-6654-4039-b75d-cde0ab6b72e3.png)
> 내가 보기엔 타입이 안전하지만 IDE에서는 경고문구를 날리고 있다.  
> 이럴때 사용하라고 있는게 아이템 27에서 배운 `@SuppressWarnings` 이다.

```java
@SuppressWarnings("unchecked")
public GenericStack() {
    elements = (E[])new Object[DEFAULT_INITIAL_CAPACITY];
}
```
#### ❓ 어떻게 확실하게 안전성이 보장된다고 확신하고 경고를 무시하게 코딩하는걸까?
  - elements 는 push(E)로 넘어온 E 인스턴스만 담게되므로 타입 안전성을 보장받을 수 있다.
  - `private E[] elements` private로 외부에서 접근이 불가능하다.
> 이러한 이유로 안전성이 보장되기에 경고를 무시하게 만들어도 된다.
#### ✅ 장점 1. 가독성이 좋다.
#### ✅ 장점 2. 형변환 생성자 호출시 한 번만 해주면 더 이상 할 필요가 없다.
#### ⛔️ 단점 1. 배열의 런타임이 컴파일타임 타입과 달라 힙 오염(heap pollution)을 일으킨다.

> 이번 Stack 예제는 예외이다.
[힙 오염이란? (예제 포함)](http://kimalam.blogspot.com/2019/09/java-heap-pollution.html)

### ✅ 해결 방법 2. Element 타입을 E[]에서 Object[]로 변경한다.

```java
public class GenericStack<E> {
    private Object[] elements;
    // 생략
    
    public GenericStack() {
      elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    // 생략
    
    public E pop() {
      if(size == 0) throw new EmptyStackException();
      E result = (E) elements[--size]; // Warning : unchecked cast
      elements[size] = null;
      return result;
    }
}
```

![image](https://user-images.githubusercontent.com/53300830/166615213-2b1cff17-3dba-419c-86e2-59ab44d6830e.png)
> elements를 Object 배열로 그대로 두고 pop으로 꺼낼 경우 정규타입 매개변수인 E로 형변환 해서 반환할 경우 이전과 같이 unckecked 경고가 뜨게 된다. 이유는 해결법 1과 같다.

```java
public E pop() {
    if(size == 0) throw new EmptyStackException();
		//push 메서드에서 E타입만 허용하기에 이 형변환은 안전하다.
		@SuppressWarnings("unchecked")
    E result = (E) elements[--size];
    elements[size] = null;
    return result;
}
```
> push 메서드에서 E타입만 허용하기에 이 형변환은 안전하다.

<hr/>

### ✅ 매개변수에 제약을 두는 제네릭 타입
```java
Stack<String> stackStr = new GenericStack<>();
Stack<Integer> stackInt = new GenericStack<>();
Stack<Double> stackDouble = new GenericStack<>();
```
> 타입 매개변수에 제약을 두지 않고 사용이 가능하다.  

<hr/>

### 📋 간단 정리  
제네릭을 사용하지 않을 경우 `매번 직접 형변환 후 넘겨줘야 하는 불편함`이 있다. 그렇기에 제네릭 타입을 사용해 이런 불편함을 해소할 수 있다.






