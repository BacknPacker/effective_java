# 아이템 26. 로 타입은 사용하지 말라.

### ❓ Raw Type(로 타입) 이란?
제너릭 타입에서 타입 매개변수를 전혀 사용하지 않는 것을 의미한다
- 예시로 `List<E>`는 raw type의 List이다.  
- `List<String>`과 같이 원소 타입을 명시해서 사용할 것을 권장한다.
  
### ❓ 왜 사용하지 말라는 걸까?
```java
public class RawType {
    public static void main(String[] args) {
        List rawType = new ArrayList();
        rawType.add("강원도");
        rawType.add(01012341234);

        for (Iterator i = rawType.iterator(); i.hasNext(); ) {
            // ClassCastException 발생
            String s = (String) i.next();
        }
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197964-0f628123-b121-4518-a9e5-f4771e8ce053.png)
> 컴파일 시점에서 잡는게 아닌 실제로 값을 가져와서 캐스팅 하는 시점에서 오류가 발생한다.  
> 오류는 발생 즉시 즉 컴파일시 발견해야 디버깅하는 관점에서도 편하기 때문이다.

```java
public static void main(String[] args) {
    List<String> parameterizedType = new ArrayList<>();

    parameterizedType.add("강원도");
    parameterizedType.add("강원도");
    parameterizedType.add(123123);

    for (String s : parameterizedType) {
        System.out.println(s);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/166197164-b23218f7-f4fb-4941-8b8c-5efb48b8af9c.png)
> 컴파일 과정에서 에러가 발생한다.  
> 컴파일 과정에서 오류가 발생하는 것과 컴파일 후에 발생하는 것은 엄청난 차이가 있다.

<hr/>

### ✅ 비한정적 와일드카드 타입
컬렉션의 원소 타입을 모를 때 혹은 컬렉션에 어떤 원소 타입이든 넣고 사용하고 싶을때 사용한다.
```java
// Set<E>에서 E가 들어갈 자리에 ?로 대체해주면 된다.
static int numElementsInCommon(Set<?> s1, Set<?> s2) {}
```

```java
public static void main(String[] args) {
    HashSet rawTypeSet = new HashSet();
    HashSet<?> wildCardSet = new HashSet<>();

    rawTypeSet.add("스트링타입");
    rawTypeSet.add(01012341234);

    wildCardSet.add("스트링타입"); // 컴파일 에러가 발생한다.
}
```
![image](https://user-images.githubusercontent.com/53300830/166201594-d4313499-aadb-4092-bea5-1f196e67e0c2.png)

> wildCardSet 컬렉션에 문자열에 어떤 타입을 넣던지간에 컴파일 에러가 발생한다.

#### ❓ 왜 사용하는걸까?
실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 `?` 로 대체할 수 있다.
```java
static void numElementsInCommon(HashSet<?> s1, HashSet<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s1.contains(s2)) result++;
    }
}
```
> 메서드 파라미터에 사용할 수 있으며, 이 메서드는 컬렉션이 어떤 타입이든지 인자로 받을 수 있다.  
> 그러므로 특정 파라미터에 맞게 일일이 메서드를 재정의할 필요가 없어진다.

# 아이템 27. 비검사 경고를 제거하라.

###❓ 비검사 경고란?
오류는 아니지만 영역이 하이라이트 되면서 개발자에게 경고를 주는 것을 말한다.
![image](https://user-images.githubusercontent.com/53300830/166394604-05fdb2bc-b796-4dfa-b9dd-7ae936c8be6b.png)
> 가끔 알고리즘 풀다가 하는 실수 중 하나이다.
```java
public static void main(String[] args) {
    int[] arr= new int[100];
}
```
> 이렇게 비검사 경고도 전부 해결해주는 것이 좋다. -> 타입 안전성 보장 (타입 시스템 자체가 잘못 되지 않음을 보장한다.)
[타입 안전성이란?](https://tlonist-sang.github.io/Today-I-learned/jekyll/update/2020/09/29/typed-language.html)

### ✅ SuppressWarning("unchecked")
경고를 제거할 수 없는 상황이지만 타입이 확실하게 안전하다고 할 수 있을때 사용하는 어노테이션이다.
> 위 어노테이션을 사용할때는 항상 신중해야한다. 

```java
@SuppressWarnings("unchecked")
class ClassWarning {
    public Set<String> hello() {
        return new HashSet();
    }
}
```
> 왜 경고를 못없애고 @SuppressWarnings("unchecked") 를 사용했는지 주석으로 남겨야한다.


