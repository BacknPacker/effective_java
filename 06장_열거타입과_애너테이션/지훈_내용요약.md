## 🚀 아이템 34. int 상수 대신 열거 타입을 사용하라.

```java
// 과일을 종류별로 상수로 지정해 놓은 Foods 클래스
public class Foods {
    public static final int APPLE_FUJI          = 0;
    public static final int APPLE_PIPPIN        = 1;
    public static final int APPLE_GRANNY_SMITH  = 2;

    public static final int ORANGE_NAVEL    = 0;
    public static final int ORANGE_TEMPLE   = 1;
    public static final int ORANGE_BLOOD    = 2;
}
```
- 타입의 안전성 보장이 되지 않는다.
- 오렌지를 건네는 세머드에 사과를 보내고 동등 연산자로 비교해도 컴파일러는 경고 없이 통과하게 된다.
- 자바는 별도의 namespace를 지원하지 않아서 접두어(APPLE, ORANGE)를 붙혀야 한다.
- 상수를 나열한 것이기 때문에 깨지기 쉽다.

> 컴파일시 그 값이 클라이언트 파일에 그대로 새겨지는데, 상수의 값이 바뀌면 클라이언트도 다시 컴파일 해야 한다.

```java
public void apple(int apple) { // 애플 관련 상수만 들어가야한다.
    ...
}
...
function(APPLE_FUJI); // OK
function(ORANGE_NAVEL); // 오렌지가 들어와서 오류가 생기지 않는다.
```

<hr/>

### ✅ 열거타입 예시 1
```java
public enum Apple{ FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange{ NAVEL, TEMPLE, BLOOD }
```
```java
public void apple(Apple apple) { // 
    ...
}
...
function(APPLE_FUJI); // OK
function(ORANGE_NAVEL); // 컴파일 에러 발생
```
- 공개되는 건 필드의 이름뿐이라서 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
- 상수를 하나 제거하더라도 제거한 상수를 참조하지 않는 클라이언트에서는 아무 영향이 없다.
  > 제거한 상수를 참조하는 클라이언트가 있으면 컴파일러가 발생하여 즉시 알아차릴 수 있다.
- 인스턴스를 통제할 수 있다.
  - 클라이언트가 인스턴스를 집접 생성하거나 확장할 수 없다. ***(public 생성자를 제공하지 않기 때문)***
  - 열거 타입 인스턴스들은 딱 하나만 존재함이 보장이 된다.

<hr/>

### ✅ 열거타입 예시 2
```java
public enum Operation {
  PLUS, MINUS, TIMES, DIVIDE;
  
  public double apply(double x, double y) {
    switch (this) {
      case PLUS: return x + y;
      case MINUS: return x - y;
      case TIMES: return x * y;
      case DIVIDE: return x / y;
    }
    // throw 구문 없이는 컴파일되지가 않는다.
    throw new AssertionError("알 수 없는 연산 :" + this);
  }
}
```
> 새로운 Operation 타입이 추가되면 switch 구문의 case가 추가해야 하는데 이 과정에서 실수하기가 쉽다.

```java
// 위 단점 개선 코드
public enum Operation {
    PLUS("+") {public double apply(double x, double y) { return x + y; }},
    MINUS("-") {public double apply(double x, double y) { return x - y; }},
    TIMES("*") {public double apply(double x, double y) { return x * y; }},
    DIVIDE("/") {public double apply(double x, double y) { return x / y; }};
    public abstract double apply(double x, double y);

    private final String symbol;

    Operation(String symbol) { this.symbol = symbol; }

    @Override public String toString() { return symbol; }
}
```
> 열거 타입에 추상메서드를 구현한 것이다.  
> 상수-한정 메서드 구현이라고도 하는데 새로운 Opertaion이 추가되더라도 다른 곳에는 영향을 아예 줄 수가 없기에 이전 코드의 아쉬운점을 해결해준다.  

```java
@Test
@DisplayName("상수-한정 메서드 구현")
void 상수_한정_메서드() {
    double x = 2.0;
    double y = 4.0;

    for (Operation value : Operation.values()) {
        System.out.printf("%f %s %f = %f%n", x, value, y, value.apply(x, y));

    }
}
```
![image](https://user-images.githubusercontent.com/53300830/167347324-3701c4df-f62e-4718-907f-01430cdcff1a.png)
> 단점을 개선했을 뿐만 아니라 가독성또한 늘렸다.

<hr/>

### ✅ 열거타입 예시 3 
```java
/**
 * 1. 업무시간(분) : 8 * 60(1일 8시간 근무 기준)
 * 2. 주중 오버타임은 잔업시간에 추가 된다.
 * 3. 주말에는 무조건 잔업수당이 주어진다.
 */

public enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;

    private static final int MINS_PER_SHIFT = 8 * 60;

    int pay(int minutesWorked, int payRate) {
        int basePay = minutesWorked * payRate;

        int overtimePay;
        switch (this) {
            case SATURDAY: case SUNDAY: // 주말인 경우
                overtimePay = basePay / 2;
                break;
            default://주중
                overtimePay = minutesWorked <= MINS_PER_SHIFT
                        ? 0
                        : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
        }
        return basePay + overtimePay;
    }
}
```
⛔️ **문제 1**. 주말과 주중을 구분하여 주중에 오버타임에 대해서는 구분을 해놨지만 그외의 잔업이 발생하는 경우에 대한 고려가 안돼있다.  
⛔️ **문제 2**. 공휴일/휴가기간 등 여러가지 추가 경우의 수를 매번 case로 추가하거나 조건을 수정해야 하는데 그럼 예시2번의 문제랑 동일해진다.

### ❓ 어떻게 해야할까? -> 전략 패턴을 사용하자!
```java
/**
 * 1. 평일 휴일을 private 중첩 열거 타입으로 만들어 옮기자.
 * 2. PayrollDay 열거타입의 생성자에서 주입받도록 한다.
 */

public enum PayrollDay {
    MONDAY(WEEKDAY), TUESDAY(WEEKDAY),
    WEDNESDAY(WEEKDAY), THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
    SATURDAY(WEEKEND), SUNDAY(WEEKEND);

    private final PayType payType;

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    int pay(int minutesWorked, int payRate) {
        return payType.pay(minutesWorked, payRate);
    }

    enum PayType {
        WEEKDAY {
            @Override
            int overtimePay(int minWorked, int payRate) {
                return minWorked <= MINS_PER_SHIFT
                        ? 0
                        : (minWorked - MINS_PER_SHIFT) * payRate / 2;
            }
        },

        WEEKEND {
            @Override
            int overtimePay(int minWorked, int payRate) {
                return minWorked * payRate / 2;
            }
        };

        abstract int overtimePay(int minWorked, int payRate);
        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minWorked, int payRate) {
            int basePay = minWorked * payRate;
            return basePay + overtimePay(minWorked, payRate);
        }
    }
}
```

<hr/>

### ❓ 그럼 switch 문은 사용안하는게 좋은것인가?
> 무조건 그런것은 아니다. 하지만 보통은 switch를 안쓰고 위처럼 코딩하는편이 실수가 적어지며 컴파일시 오류잡기가 편해진다.

```java
// 각각의 타입의 반대 연산을 반환하는 메서드를 구현해야 한다면 적절한 선택이 될 수도 있다.
public static Operation inverse(Operation op) {
    switch(op) {
        case PLUS: return Operation.MINUS;
        case MINUS: return Operation.PLUS;
        case TIMES: return Operation.DIVIDE;
        case DIVIDE: return Operation.TIMES;
        default: throw new AssertionError("알 수 없는 연산" + op);
    }
}
```

### 📋 정리 
- 성능은 정수 상수와 크게 차이가 나지는 않는다.
- 위에서 작성한 사칙연산과 같이 원소를 컴파일 타엠에서 다 알 수 있는 상수 집합이라면 열거 타입을 사용하자.
> 실수를 방지하기 위해서 switch문 대신 전략 패턴 사용하는 것을 습관화하자.

## 🚀 아이템 35. ordianl 메서드 대신 인스턴스 필드를 사용하라.
```java
// oridnal 예시 -> 따라하지 말것
// 상수가 몇 번째 위치인지를 반환하는 ordinal메서드
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET, SEXTET, SEPTET, OCTET, NONET, DECTET;

    public int numberOfMusicians(){ return ordinal() + 1; }
}
```
- 연주자가 1명인 솔로부터 10명인 디텍트까지 정의한 열거타입이다.
- `numberOfmusicians()` 를 호출하면 적절한 숫자가 반환되며 원하는대로 작동한다.
```java
class EnsembleTest {

    @Test
    @DisplayName("열거타입 테스트")
    void 열거타입테스트() {
        Assertions.assertEquals(Ensemble.DECTET.numberOfMusicians(), 10);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/167518948-ae49b8b5-adba-4321-8a36-34f79d3fb08e.png)

 ### ❓ 잘 작동하는데 왜 인스턴스 필드를 사용하라는거지?
 순서에 영향을 준다는것이 문제이다.  
 > SOLO와 DUET위치를 바꾸기만해도 반환값이 달라지게 된다.  
 > 그리고 3중 4중주(triple quartet) 같은 것을 추가할려면 12의 값이므로 11번째 값도 추가해야하는데 11명 짜리 연주를 일컫는 말이 없다.

### 📋 해결 방법 : 인스턴스 필드에 저장하자.
```java
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), 
    QUARTET(4), QUINTET(5), SEXTET(6), 
    SEPTET(7), OCTET(8), NONET(9), 
    DECTET(10), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;

    Ensemble(int numberOfMusicians) {
        this.numberOfMusicians = numberOfMusicians;
    }

    public int numberOfMusicians() {
        return numberOfMusicians;
    }
}
```

![image](https://user-images.githubusercontent.com/53300830/167518629-4923ebbf-3f23-4f49-8771-76477cc4b0d3.png)
> Enum API에서도 ordinal 메서드는 대부분의 프로그래머가 쓸 일이 없으며   
> EnumSet, EnumMap과 같이 열거 타입 기반에서 사용되는 것이라고 명시돼 있다.

## 🚀 아이템 36. 비트 필드 대신 EnumSet을 사용하라.
**비트 필드 :** 비트별 OR을 사용해 여러 상수를 하나로 모은 집합을 비트 필드라고 한다.   
```java
// 구닥다리 방법
public class Text {
    public static final int STYLE_BOLD          = 1 << 0; //1
    public static final int STYLE_ITALIC        = 1 << 1; //2
    public static final int STYLE_UNDERLINE     = 1 << 2; //4
    public static final int STYLE_STRIKETHROUGH = 1 << 3; //8

    public void applyStyles(int styles) {
    }
}
```
위와 같은 비트 필드 열거 상수가 있다고 할 때, 아래와 같이 만들어진 집합을 비트필드라고 한다.  
```java 
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```
비트필드를 사용하면 비트 연산을 사용해 합집합과 교집합 같은 집합 연산을 효율적으로 수행할 수 있다.  

### ❓ 그럼 왜 EnumSet을 사용하라고 하는걸까?
1. 정수 열거 상수의 단점을 그대로 가져간다. 
2. 비트 필드 값이 그대로 출력되면 해석하기가 곤란하다.
3. 비트 필드 하나에 녹아 있는 모든 원소를 순회하기가 까다롭다.
4. 최대 몇 비트가 필요한지 API 작성시 미리 예측해 적절한 타입을 선택해야 한다. (int, long)
> 위와 같은 이유 때문에 비트 필드 대신 EnumSet을 추천한다.

### 📋 EumSet 사용해서 해결해보자.
```java
public class Text {  
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }
    // 어떤 Set을 넣어도 되지만 EnumSet이 제일 좋다. 
    public void applyStyles(Set<Style> styleSet){ ... }
}
```
> 비트를 직접 다룰 때 겪는 문제들을 EnumSet이 대부분 해결해준다.
```java
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

### ❓ EnumSet이 가장 좋다면서 왜 Set을 넘길까?
모든 클라이언트가 EnumSet을 건네리라 짐작되는 상황이더라도 인터페이스로 받는게 좋은 습관이다.(아이템 64)  
> 짐작이 될 뿐 확실하게 모든 클라이언트가 넘기지 않을 경우를 대비한다는 느낌으로 이해하면 좋다.



