## 아이템 34. int 상수 대신 열거 타입을 사용하라.

```java
// 과일을 종류별로 상수로 지정해 놓은 Foods 클래스
public class Foods {
    public static final int APPLE_FUJI          = 0;
    public static final int APPLE_PIPPIN        = 1;
    public static final int APPLE_GRANNY_SMITH  = 2;

    public static final int ORANGE_NAVEL    = 0;
    public static final int ORANGE_TEMPLE   = 1;
    public static final int ORANGE_BLOOD    = 2;
}
```
- 타입의 안전성 보장이 되지 않는다.
- 오렌지를 건네는 세머드에 사과를 보내고 동등 연산자로 비교해도 컴파일러는 경고 없이 통과하게 된다.
- 자바는 별도의 namespace를 지원하지 않아서 접두어(APPLE, ORANGE)를 붙혀야 한다.
- 상수를 나열한 것이기 때문에 깨지기 쉽다.

> 컴파일시 그 값이 클라이언트 파일에 그대로 새겨지는데, 상수의 값이 바뀌면 클라이언트도 다시 컴파일 해야 한다.

```java
public void apple(int apple) { // 애플 관련 상수만 들어가야한다.
    ...
}
...
function(APPLE_FUJI); // OK
function(ORANGE_NAVEL); // 오렌지가 들어와서 오류가 생기지 않는다.
```

<hr/>

### ✅ 열거타입 예시 1
```java
public enum Apple{ FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange{ NAVEL, TEMPLE, BLOOD }
```
```java
public void apple(Apple apple) { // 
    ...
}
...
function(APPLE_FUJI); // OK
function(ORANGE_NAVEL); // 컴파일 에러 발생
```
- 공개되는 건 필드의 이름뿐이라서 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
- 상수를 하나 제거하더라도 제거한 상수를 참조하지 않는 클라이언트에서는 아무 영향이 없다.
  > 제거한 상수를 참조하는 클라이언트가 있으면 컴파일러가 발생하여 즉시 알아차릴 수 있다.
- 인스턴스를 통제할 수 있다.
  - 클라이언트가 인스턴스를 집접 생성하거나 확장할 수 없다. ***(public 생성자를 제공하지 않기 때문)***
  - 열거 타입 인스턴스들은 딱 하나만 존재함이 보장이 된다.

<hr/>

### ✅ 열거타입 예시 2
```java
public enum Operation {
  PLUS, MINUS, TIMES, DIVIDE;
  
  public double apply(double x, double y) {
    switch (this) {
      case PLUS: return x + y;
      case MINUS: return x - y;
      case TIMES: return x * y;
      case DIVIDE: return x / y;
    }
    // throw 구문 없이는 컴파일되지가 않는다.
    throw new AssertionError("알 수 없는 연산 :" + this);
  }
}
```
> 새로운 Operation 타입이 추가되면 switch 구문의 case가 추가해야 하는데 이 과정에서 실수하기가 쉽다.

```java
// 위 단점 개선 코드
public enum Operation {
    PLUS("+") {public double apply(double x, double y) { return x + y; }},
    MINUS("-") {public double apply(double x, double y) { return x - y; }},
    TIMES("*") {public double apply(double x, double y) { return x * y; }},
    DIVIDE("/") {public double apply(double x, double y) { return x / y; }};
    public abstract double apply(double x, double y);

    private final String symbol;

    Operation(String symbol) { this.symbol = symbol; }

    @Override public String toString() { return symbol; }
}
```
> 열거 타입에 추상메서드를 구현한 것이다.  
> 상수-한정 메서드 구현이라고도 하는데 새로운 Opertaion이 추가되더라도 다른 곳에는 영향을 아예 줄 수가 없기에 이전 코드의 아쉬운점을 해결해준다.  

```java
@Test
@DisplayName("상수-한정 메서드 구현")
void 상수_한정_메서드() {
    double x = 2.0;
    double y = 4.0;

    for (Operation value : Operation.values()) {
        System.out.printf("%f %s %f = %f%n", x, value, y, value.apply(x, y));

    }
}
```
![image](https://user-images.githubusercontent.com/53300830/167347324-3701c4df-f62e-4718-907f-01430cdcff1a.png)
> 단점을 개선했을 뿐만 아니라 가독성또한 늘렸다.

<hr/>

### ✅ 열거타입 예시 3 
```java
/**
 * 1. 업무시간(분) : 8 * 60(1일 8시간 근무 기준)
 * 2. 주중 오버타임은 잔업시간에 추가 된다.
 * 3. 주말에는 무조건 잔업수당이 주어진다.
 */

public enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;

    private static final int MINS_PER_SHIFT = 8 * 60;

    int pay(int minutesWorked, int payRate) {
        int basePay = minutesWorked * payRate;

        int overtimePay;
        switch (this) {
            case SATURDAY: case SUNDAY: // 주말인 경우
                overtimePay = basePay / 2;
                break;
            default://주중
                overtimePay = minutesWorked <= MINS_PER_SHIFT
                        ? 0
                        : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
        }
        return basePay + overtimePay;
    }
}
```
⛔️ **문제 1**. 주말과 주중을 구분하여 주중에 오버타임에 대해서는 구분을 해놨지만 그외의 잔업이 발생하는 경우에 대한 고려가 안돼있다.  
⛔️ **문제 2**. 공휴일/휴가기간 등 여러가지 추가 경우의 수를 매번 case로 추가하거나 조건을 수정해야 하는데 그럼 예시2번의 문제랑 동일해진다.

### ❓ 어떻게 해야할까? -> 전략 패턴을 사용하자!
```java
/**
 * 1. 평일 휴일을 private 중첩 열거 타입으로 만들어 옮기자.
 * 2. PayrollDay 열거타입의 생성자에서 주입받도록 한다.
 */

public enum PayrollDay {
    MONDAY(WEEKDAY), TUESDAY(WEEKDAY),
    WEDNESDAY(WEEKDAY), THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
    SATURDAY(WEEKEND), SUNDAY(WEEKEND);

    private final PayType payType;

    PayrollDay(PayType payType) {
        this.payType = payType;
    }

    int pay(int minutesWorked, int payRate) {
        return payType.pay(minutesWorked, payRate);
    }

    enum PayType {
        WEEKDAY {
            @Override
            int overtimePay(int minWorked, int payRate) {
                return minWorked <= MINS_PER_SHIFT
                        ? 0
                        : (minWorked - MINS_PER_SHIFT) * payRate / 2;
            }
        },

        WEEKEND {
            @Override
            int overtimePay(int minWorked, int payRate) {
                return minWorked * payRate / 2;
            }
        };

        abstract int overtimePay(int minWorked, int payRate);
        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minWorked, int payRate) {
            int basePay = minWorked * payRate;
            return basePay + overtimePay(minWorked, payRate);
        }
    }
}
```

<hr/>

### ❓ 그럼 switch 문은 사용안하는게 좋은것인가?
> 무조건 그런것은 아니다. 하지만 보통은 switch를 안쓰고 위처럼 코딩하는편이 실수가 적어지며 컴파일시 오류잡기가 편해진다.

```java
// 각각의 타입의 반대 연산을 반환하는 메서드를 구현해야 한다면 적절한 선택이 될 수도 있다.
public static Operation inverse(Operation op) {
    switch(op) {
        case PLUS: return Operation.MINUS;
        case MINUS: return Operation.PLUS;
        case TIMES: return Operation.DIVIDE;
        case DIVIDE: return Operation.TIMES;
        default: throw new AssertionError("알 수 없는 연산" + op);
    }
}
```

### 📋 정리 
- 성능은 정수 상수와 크게 차이가 나지는 않는다.
- 위에서 작성한 사칙연산과 같이 원소를 컴파일 타엠에서 다 알 수 있는 상수 집합이라면 열거 타입을 사용하자.
> 실수를 방지하기 위해서 switch문 대신 전략 패턴 사용하는 것을 습관화하자.


