## 4장 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화해라.

### ❓ 잘 설계된 컴포넌트란?
- 캡슐화가 얼마나 잘 돼있는지 (꼭 필요한 정보들만 공개를 했는가)
- 구현과 API를 분리했는가
> 이러한 개념을 정보은닉, 캡슐화 라고 한다.

### ✅ 정보은닉(캡슐화) 의 장점
> 컴포넌트를 서로 독립시켜 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 하는것과 연관돼있다.
  1. **시스템 개발 속도를 높힌다.**    -> 여러 컴포넌트를 **병렬**로 개발 할 수 있기 때문
  2. **시스템 관리 비용을 낮춘다. (컴포넌트 교체 비용 절감)**    -> 컴포넌트 이해도가 높아져 디버깅할 수 있고, 교체 부담도 적기때문
  3. **성능 최적화에 도움을 준다.**    -> 최적화할 컴포넌트를 정하고 다른 컴포넌트에 영향을 주지않는 것만으로도 최적화가 될 수 있다.
  4. **소프트웨어 재사용성을 높힌다.**  -> 외부에 존재하지 않고 독자적으로 가능한 컴포넌트는 다른 시스템에서도 바로 적용이 가능하기 때문이다.
  5. **제작하는 난이도를 낮춰준다.**   -> 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

<hr/>

### ✅ 자바의 정보 은닉을 위한 장치
|                 | 해당 클래스 안에서 접근 가능 | 같은 패키지 안에서 접근 가능 | 상속받은 클래스에서 접근 가능 | 외부에서 접근 가능 |
| --------------- | ----------------------------- | ----------------------------- | ------------------------------ | ------------------- |
| public          | O                             | O                             | O                              | O                   |
| protected       | O                             | O                             | O                              | X                   |
| package-private | O                             | O                             | X                              | X                   |
| private         | O                             | X                             | X                              | X                   |

접근성 : private -> package-private(default) -> protected -> public
> 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁히는 것이다.

### ⛔️ public 클래스의 인스턴스 필드는 되도록 public이 되서는 안되는 이유
  1. **변경에 매우 취약하다.**
  2. 필드가 수정될 때 막을 수 없기에 public 가변필드를 갖는 클래스는 **스레드 안전하지 않다.**
  3. final이면서 불변 객체를 참조하더라도 내부 구현을 바꾸지 못하기에 **public final의 문제점**이 있다.### 

#### 해결책
- 접근 제어자를 private로 만들고 public 불변리스트에 추가
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final List<Thing> VALUES = 
      Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
  ```
- 배열을 private로 만들고 복사본을 반환하는 public메서드를 추가하는 방법 (방어적 복사)
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final Thing[] values() {
      return PRIVATE_VALUES.clone();
  }
  ```
  
## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
```java
class Point {
	public double x;
	public double y;
}
```
> 위치 정보를 가져오는 Point 클래스이다. 하지만 데이터 필드에 직접 접근 할 수 있으니 캡슐화(정보은닉)의 이점을 제공하지 못한다.

```java
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }

    public void setX(double x) { this.x = x; }

    public double getY() { return y; }

    public void setY(double y) { this.y = y; }
}
```
> Getter와 Setter 메서드를 활용해 데이터 캡슐화

## 아이템 17. 변경 가능성을 최소화하라

### ✅ 불변 클래스
#### 불변이라는 개념을 클래스에 적용하려면 그 클래스 정보로 생성된 인스턴스의 내부 값들은 생성 후에는 수정할 수 없어야한다.

### 📋 불변 클래스를 만드는 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
	- setter 메서드처럼 필드를 수정해서는 안된다.
2. 클새르르 확장할 수 없도록 한다.
	- 의도치 않은 객체의 상태 변경을 막아야한다.
3. 모든 필드를 final로 선언한다.
 	- 작성자의 의도를 명확하게 드러낸다. 
	- 멀티 스레드 환경에서도 문제 없이 동작하게 보장하는데 필요하다.
4. 모든 필드를 private로 선언한다.
	- 클라이언트에서 직접 멤버에 접근하여 수정하는 일을 막아준다.
5. 자신외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.
	- 클래스에서 가변객체를 참조하는 필드가 하나라도 있으면 클라이언트에서 그 객체의 참조를 못하도록 해야한다.
	- 접근자 메서드가 그 필드를 그래도 반환해서도 안된다.

```java
public class Member {

    private final Long id;
    private final String name;
    private final Address address;

    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Address getAddress() {
        return address;
    }
}
```

```java
public class Address {

    private String post;

    public String getPost() {
        return post;
    }

    public void setPost(String post) {
        this.post = post;
    }
}
```
```java
class MemberTest {
    @Test
    @DisplayName("불변 객체 테스트")
    void 불견객체_테스트() {
        Address address = new Address();
        address.setPost("용산");

        Member member = new Member(0L, "이지훈", address);
        String YongSan = member.getAddress().getPost();

        address.setPost("서울");
        String seoul = member.getAddress().getPost();

        assertNotEquals(YongSan, seoul); // 통과 한다
    }
}
```
> 즉 Address 객체가 변경되면 Member의 객체도 변경이 된다는 뜻

```java
public class Address {

    private final String post;

    public Address(String post) {
        this.post = post;
    }

    public String getPost() {
        return post;
    }

}
```
```java
    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.post = new Address(address.getPost());
    }
```
> 불변으로 만들기 위해서는 위 처럼 코드를 수정해서 사용해야한다.

### ✅ 장점과 단점   
#### 장점 1. 단순하다.
	오류가 생길 여지가 적고, 불변식을 유지하기 쉽다.
#### 장점 2. 자유롭게 공유할 수 있다.
	Thread-Safe를 보장한다. -> 변경되지 않으므로 여러 스레드에서 접근하더라도 훼손되지 않는다.
	방어적 복사가 필요 없다. -> 복사를 해도 수정을 할 수 없기 때문에 결국 원본가 같은 상태이다.
	불변 객체끼리는 내부 데이터를 공유할 수 있다. -> 가변 객체를 참조하더라도 접근/변경을 막아둔 상태이기때문에 그 필드는 불변이기 때문이다.
#### 단점 1. 인스턴스 생성에 대한 문제	
	인스턴스 생성비용이 큰 경우 문제가 된다. 

#### 해결방법 1. 인스턴스 캐싱
	인스턴스 캐싱을 통해 인스턴스를 새로 생성하지 않고 재사용하여 비용을 줄인다.
	자바의 대부분의 기본값 wrapper클래스에서 사용되고 있는 방식이다. (Boolean, Integer, String...)
#### 해결방법 2. 다단계 연산 예측하여 기본 기능으로 제공
	인스턴스를 생성하는데 여러 단계를 거치는데, 이 단계들을 예측하여 기능으로 제공하는 것을 뜻한다.
	불변 객체 String은 가변 동반 클래스인 StringBuilder를 제공한다.
	StringBuilder에서는 String 인스턴스를 생성하는 여러 단계를 쪼개어 가변으로 객체를 생성할 수 있는 기능을 제공한다.
	
	
## 아이템 18. 상속보다는 컴포지션을 사용하라.
### ❓ 상속이란? 그리고 왜 사용할까?
두 개의 클래스가 있을 때 상위/하위 클래스로 관계를 맺는 방법이다.  
즉 하위 클래스가 상위 클래스의 특정을 재사용하고 확장한다.  
하위 클래스에서 `extends` 를 이용해서 상속관계로 만들 수 있다.
```java
// 하위 클래스 : MarketRepositoryExtensionImpl
// 상위 클래스 : QuerydslRepositorySupport
public class MarketRepositoryExtensionImpl extends QuerydslRepositorySupport
```
> 상속(Inheritance)이라고 하지만 연장/확장(extends)라고 하는 이유  
> 코드를 재사용하고 추가로 확장의 관점까지 볼 수 있으므로 extends가 좀 더 어울린다. 




### 상속의 단점
객체를 재사용하면서 확장까지 고려할 때 상속은 꽤나 큰 걸림돌이 될 수 있다.
> 즉 상속은 캡슐화를 깨트릴 수 있다.

```java
// 상위 클래스 HashSet
// 하위 클래스 InstrumentedHashSet
public class InstrumentedHashSet<E> extends HashSet<E> {

    private int addCount = 0;

    public InstrumentedHashSet(int initCap, float loadFactor) {
        super(initCap, loadFactor);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```
```java
class InstrumentedHashSetTest {

    @Test
    @DisplayName("상속 테스트")
    void 상속_테스트() {
        InstrumentedHashSet<String> objects = new InstrumentedHashSet<>(1, 2);

        objects.addAll(List.of("가", "나", "다"));

        assertEquals(objects.getAddCount(), 3);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/165884735-08bcbed6-c4a1-4858-93c7-d9dc50868be3.png)
> 3이 출력이 돼야 하지만 6이 반환된다.

#### ❓ 왜 6이 반환된걸까?
	HashSet 클래스의 addAll 메서드가 내부적으로 add를 구현하는데 원인이 있다.  
	addAll에 3개의 원자가 추가 되고 로직 내부에 있는 add를 호출하게 되므로 결국 인자당 2회씩 addAccount가 된것이다.
	
```java
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e)) // add 가 중복으로 일어나게 된다.
                modified = true;
        return modified;
    }
```

#### ✅ 해결방법 : addAll을 재정의하지 않거나 다른 식의 재정의를 통해 해결을 할 수 있다.

### ✅ 상속보단 컴포지션을 사용해보자.
> 컴포지션 : 기존 클래스를 확장하지 않고, 새로운 클래스를 만든 후, private 필드로 기존 클래스의 인스턴스를 참조하게 하도록 설계하는 방법

#### ❓ 왜 사용하고 어떻게 사용하는걸까?
재정의하는 일이 없어 위의 상속처럼 문제가 될 일이 적어지게 됩니다.

```java
public class CustomHashSetByComposition<E> {
    private final HashSet<E> hashSet;
    private int addCount = 0;

    public CustomHashSetByComposition(HashSet<E> hashSet) {
        this.hashSet = hashSet;
    }

    public boolean add(E e) {
        addCount++;
        return hashSet.add(e);
    }

    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return hashSet.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```
```java
class CustomHashSetByCompositionTest {
    @Test
    @DisplayName("컴포지션 테스트")
    void 컴포지션_테스트() {
        CustomHashSetByComposition<Object> custom = new CustomHashSetByComposition<>(new HashSet<>());

        custom.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7));

        assertEquals(custom.getAddCount(), 7);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/165886563-83fdb31b-a984-4292-92ba-9a890e9c48b6.png)

### 📋 정리
- 상속은 캡슐화를 깨트린다.
- 하위 클래스의 관계가 온전한 is-a 관계일때만 사용해야한다.
- is-a 관계일때도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려하지 않을때 문제가 발생한다.
- 대부분의 경우 컴포지션과 전달을 사용하자. 


