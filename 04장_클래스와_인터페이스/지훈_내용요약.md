## 4장 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화해라.

### ❓ 잘 설계된 컴포넌트란?
- 캡슐화가 얼마나 잘 돼있는지 (꼭 필요한 정보들만 공개를 했는가)
- 구현과 API를 분리했는가
> 이러한 개념을 정보은닉, 캡슐화 라고 한다.

### ✅ 정보은닉(캡슐화) 의 장점
> 컴포넌트를 서로 독립시켜 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 하는것과 연관돼있다.
  1. **시스템 개발 속도를 높힌다.**    -> 여러 컴포넌트를 **병렬**로 개발 할 수 있기 때문
  2. **시스템 관리 비용을 낮춘다. (컴포넌트 교체 비용 절감)**    -> 컴포넌트 이해도가 높아져 디버깅할 수 있고, 교체 부담도 적기때문
  3. **성능 최적화에 도움을 준다.**    -> 최적화할 컴포넌트를 정하고 다른 컴포넌트에 영향을 주지않는 것만으로도 최적화가 될 수 있다.
  4. **소프트웨어 재사용성을 높힌다.**  -> 외부에 존재하지 않고 독자적으로 가능한 컴포넌트는 다른 시스템에서도 바로 적용이 가능하기 때문이다.
  5. **제작하는 난이도를 낮춰준다.**   -> 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

<hr/>

### ✅ 자바의 정보 은닉을 위한 장치
|                 | 해당 클래스 안에서 접근 가능 | 같은 패키지 안에서 접근 가능 | 상속받은 클래스에서 접근 가능 | 외부에서 접근 가능 |
| --------------- | ----------------------------- | ----------------------------- | ------------------------------ | ------------------- |
| public          | O                             | O                             | O                              | O                   |
| protected       | O                             | O                             | O                              | X                   |
| package-private | O                             | O                             | X                              | X                   |
| private         | O                             | X                             | X                              | X                   |

접근성 : private -> package-private(default) -> protected -> public
> 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁히는 것이다.

### ⛔️ public 클래스의 인스턴스 필드는 되도록 public이 되서는 안되는 이유
  1. **변경에 매우 취약하다.**
  2. 필드가 수정될 때 막을 수 없기에 public 가변필드를 갖는 클래스는 **스레드 안전하지 않다.**
  3. final이면서 불변 객체를 참조하더라도 내부 구현을 바꾸지 못하기에 **public final의 문제점**이 있다.### 

#### 해결책
- 접근 제어자를 private로 만들고 public 불변리스트에 추가
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final List<Thing> VALUES = 
      Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
  ```
- 배열을 private로 만들고 복사본을 반환하는 public메서드를 추가하는 방법 (방어적 복사)
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final Thing[] values() {
      return PRIVATE_VALUES.clone();
  }
  ```
  
## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
```java
class Point {
		public double x;
		public double y;
}
```
> 위치 정보를 가져오는 Point 클래스이다. 하지만 데이터 필드에 직접 접근 할 수 있으니 캡슐화(정보은닉)의 이점을 제공하지 못한다.

```java
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }

    public void setX(double x) { this.x = x; }

    public double getY() { return y; }

    public void setY(double y) { this.y = y; }
}
```
> Getter와 Setter 메서드를 활용해 데이터 캡슐화

## 아이템 17. 변경 가능성을 최소화하라

### ✅ 불변 클래스
#### 불변이라는 개념을 클래스에 적용하려면 그 클래스 정보로 생성된 인스턴스의 내부 값들은 생성 후에는 수정할 수 없어야한다.

### 📋 불변 클래스를 만드는 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
	- setter 메서드처럼 필드를 수정해서는 안된다.
2. 클새르르 확장할 수 없도록 한다.
	- 의도치 않은 객체의 상태 변경을 막아야한다.
3. 모든 필드를 final로 선언한다.
 	- 작성자의 의도를 명확하게 드러낸다. 
	- 멀티 스레드 환경에서도 문제 없이 동작하게 보장하는데 필요하다.
4. 모든 필드를 private로 선언한다.
	- 클라이언트에서 직접 멤버에 접근하여 수정하는 일을 막아준다.
5. 자신외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.
	- 클래스에서 가변객체를 참조하는 필드가 하나라도 있으면 클라이언트에서 그 객체의 참조를 못하도록 해야한다.
	- 접근자 메서드가 그 필드를 그래도 반환해서도 안된다.

```java
public class Member {

    private final Long id;
    private final String name;
    private final Address address;

    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Address getAddress() {
        return address;
    }
}
```

```java
public class Address {

    private String post;

    public String getPost() {
        return post;
    }

    public void setPost(String post) {
        this.post = post;
    }
}
```
```java
class MemberTest {
    @Test
    @DisplayName("불변 객체 테스트")
    void 불견객체_테스트() {
        Address address = new Address();
        address.setPost("용산");

        Member member = new Member(0L, "이지훈", address);
        String YongSan = member.getAddress().getPost();

        address.setPost("서울");
        String seoul = member.getAddress().getPost();

        assertNotEquals(YongSan, seoul); // 통과 한다
    }
}
```
> 즉 Address 객체가 변경되면 Member의 객체도 변경이 된다는 뜻

```java
public class Address {

    private final String post;

    public Address(String post) {
        this.post = post;
    }

    public String getPost() {
        return post;
    }

}
```
```java
    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.post = new Address(address.getPost());
    }
```
> 불변으로 만들기 위해서는 위 처럼 코드를 수정해서 사용해야한다.

### ✅ 장점과 단점   
#### 장점 1. 단순하다.
	오류가 생길 여지가 적고, 불변식을 유지하기 쉽다.
#### 장점 2. 자유롭게 공유할 수 있다.
	Thread-Safe를 보장한다. -> 변경되지 않으므로 여러 스레드에서 접근하더라도 훼손되지 않는다.
	방어적 복사가 필요 없다. -> 복사를 해도 수정을 할 수 없기 때문에 결국 원본가 같은 상태이다.
	불변 객체끼리는 내부 데이터를 공유할 수 있다. -> 가변 객체를 참조하더라도 접근/변경을 막아둔 상태이기때문에 그 필드는 불변이기 때문이다.
#### 단점 1. 인스턴스 생성에 대한 문제	
	인스턴스 생성비용이 큰 경우 문제가 된다. 

#### 해결방법 1. 인스턴스 캐싱
	인스턴스 캐싱을 통해 인스턴스를 새로 생성하지 않고 재사용하여 비용을 줄인다.
	자바의 대부분의 기본값 wrapper클래스에서 사용되고 있는 방식이다. (Boolean, Integer, String...)tto
#### 해결방법 2. 다단계 연산 예측하여 기본 기능으로 제공
	인스턴스를 생성하는데 여러 단계를 거치는데, 이 단계들을 예측하여 기능으로 제공하는 것을 뜻한다.
	불변 객체 String은 가변 동반 클래스인 StringBuilder를 제공한다.
	StringBuilder에서는 String 인스턴스를 생성하는 여러 단계를 쪼개어 가변으로 객체를 생성할 수 있는 기능을 제공한다.

