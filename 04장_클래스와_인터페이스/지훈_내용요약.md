## 4장 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화해라.

### ❓ 잘 설계된 컴포넌트란?
- 캡슐화가 얼마나 잘 돼있는지 (꼭 필요한 정보들만 공개를 했는가)
- 구현과 API를 분리했는가
> 이러한 개념을 정보은닉, 캡슐화 라고 한다.

### ✅ 정보은닉(캡슐화) 의 장점
> 컴포넌트를 서로 독립시켜 개발, 테스트, 최적화, 적용, 분석, 수정을 개별적으로 할 수 있게 하는것과 연관돼있다.
  1. **시스템 개발 속도를 높힌다.**    -> 여러 컴포넌트를 **병렬**로 개발 할 수 있기 때문
  2. **시스템 관리 비용을 낮춘다. (컴포넌트 교체 비용 절감)**    -> 컴포넌트 이해도가 높아져 디버깅할 수 있고, 교체 부담도 적기때문
  3. **성능 최적화에 도움을 준다.**    -> 최적화할 컴포넌트를 정하고 다른 컴포넌트에 영향을 주지않는 것만으로도 최적화가 될 수 있다.
  4. **소프트웨어 재사용성을 높힌다.**  -> 외부에 존재하지 않고 독자적으로 가능한 컴포넌트는 다른 시스템에서도 바로 적용이 가능하기 때문이다.
  5. **제작하는 난이도를 낮춰준다.**   -> 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

<hr/>

### ✅ 자바의 정보 은닉을 위한 장치
|                 | 해당 클래스 안에서 접근 가능 | 같은 패키지 안에서 접근 가능 | 상속받은 클래스에서 접근 가능 | 외부에서 접근 가능 |
| --------------- | ----------------------------- | ----------------------------- | ------------------------------ | ------------------- |
| public          | O                             | O                             | O                              | O                   |
| protected       | O                             | O                             | O                              | X                   |
| package-private | O                             | O                             | X                              | X                   |
| private         | O                             | X                             | X                              | X                   |

접근성 : private -> package-private(default) -> protected -> public
> 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁히는 것이다.

### ⛔️ public 클래스의 인스턴스 필드는 되도록 public이 되서는 안되는 이유
  1. **변경에 매우 취약하다.**
  2. 필드가 수정될 때 막을 수 없기에 public 가변필드를 갖는 클래스는 **스레드 안전하지 않다.**
  3. final이면서 불변 객체를 참조하더라도 내부 구현을 바꾸지 못하기에 **public final의 문제점**이 있다.### 

#### 해결책
- 접근 제어자를 private로 만들고 public 불변리스트에 추가
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final List<Thing> VALUES = 
      Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
  ```
- 배열을 private로 만들고 복사본을 반환하는 public메서드를 추가하는 방법 (방어적 복사)
  ```java
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final Thing[] values() {
      return PRIVATE_VALUES.clone();
  }
  ```
  
## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
```java
class Point {
	public double x;
	public double y;
}
```
> 위치 정보를 가져오는 Point 클래스이다. 하지만 데이터 필드에 직접 접근 할 수 있으니 캡슐화(정보은닉)의 이점을 제공하지 못한다.

```java
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }

    public void setX(double x) { this.x = x; }

    public double getY() { return y; }

    public void setY(double y) { this.y = y; }
}
```
> Getter와 Setter 메서드를 활용해 데이터 캡슐화

## 아이템 17. 변경 가능성을 최소화하라

### ✅ 불변 클래스
#### 불변이라는 개념을 클래스에 적용하려면 그 클래스 정보로 생성된 인스턴스의 내부 값들은 생성 후에는 수정할 수 없어야한다.

### 📋 불변 클래스를 만드는 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
	- setter 메서드처럼 필드를 수정해서는 안된다.
2. 클새르르 확장할 수 없도록 한다.
	- 의도치 않은 객체의 상태 변경을 막아야한다.
3. 모든 필드를 final로 선언한다.
 	- 작성자의 의도를 명확하게 드러낸다. 
	- 멀티 스레드 환경에서도 문제 없이 동작하게 보장하는데 필요하다.
4. 모든 필드를 private로 선언한다.
	- 클라이언트에서 직접 멤버에 접근하여 수정하는 일을 막아준다.
5. 자신외에는 내부의 가변 컴포넌트에 접근 할 수 없도록 한다.
	- 클래스에서 가변객체를 참조하는 필드가 하나라도 있으면 클라이언트에서 그 객체의 참조를 못하도록 해야한다.
	- 접근자 메서드가 그 필드를 그래도 반환해서도 안된다.

```java
public class Member {

    private final Long id;
    private final String name;
    private final Address address;

    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Address getAddress() {
        return address;
    }
}
```

```java
public class Address {

    private String post;

    public String getPost() {
        return post;
    }

    public void setPost(String post) {
        this.post = post;
    }
}
```
```java
class MemberTest {
    @Test
    @DisplayName("불변 객체 테스트")
    void 불견객체_테스트() {
        Address address = new Address();
        address.setPost("용산");

        Member member = new Member(0L, "이지훈", address);
        String YongSan = member.getAddress().getPost();

        address.setPost("서울");
        String seoul = member.getAddress().getPost();

        assertNotEquals(YongSan, seoul); // 통과 한다
    }
}
```
> 즉 Address 객체가 변경되면 Member의 객체도 변경이 된다는 뜻

```java
public class Address {

    private final String post;

    public Address(String post) {
        this.post = post;
    }

    public String getPost() {
        return post;
    }

}
```
```java
    public Member(Long id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.post = new Address(address.getPost());
    }
```
> 불변으로 만들기 위해서는 위 처럼 코드를 수정해서 사용해야한다.

### ✅ 장점과 단점   
#### 장점 1. 단순하다.
	오류가 생길 여지가 적고, 불변식을 유지하기 쉽다.
#### 장점 2. 자유롭게 공유할 수 있다.
	Thread-Safe를 보장한다. -> 변경되지 않으므로 여러 스레드에서 접근하더라도 훼손되지 않는다.
	방어적 복사가 필요 없다. -> 복사를 해도 수정을 할 수 없기 때문에 결국 원본가 같은 상태이다.
	불변 객체끼리는 내부 데이터를 공유할 수 있다. -> 가변 객체를 참조하더라도 접근/변경을 막아둔 상태이기때문에 그 필드는 불변이기 때문이다.
#### 단점 1. 인스턴스 생성에 대한 문제	
	인스턴스 생성비용이 큰 경우 문제가 된다. 

#### 해결방법 1. 인스턴스 캐싱
	인스턴스 캐싱을 통해 인스턴스를 새로 생성하지 않고 재사용하여 비용을 줄인다.
	자바의 대부분의 기본값 wrapper클래스에서 사용되고 있는 방식이다. (Boolean, Integer, String...)
#### 해결방법 2. 다단계 연산 예측하여 기본 기능으로 제공
	인스턴스를 생성하는데 여러 단계를 거치는데, 이 단계들을 예측하여 기능으로 제공하는 것을 뜻한다.
	불변 객체 String은 가변 동반 클래스인 StringBuilder를 제공한다.
	StringBuilder에서는 String 인스턴스를 생성하는 여러 단계를 쪼개어 가변으로 객체를 생성할 수 있는 기능을 제공한다.
	
	
## 아이템 18. 상속보다는 컴포지션을 사용하라.
### ❓ 상속이란? 그리고 왜 사용할까?
두 개의 클래스가 있을 때 상위/하위 클래스로 관계를 맺는 방법이다.  
즉 하위 클래스가 상위 클래스의 특정을 재사용하고 확장한다.  
하위 클래스에서 `extends` 를 이용해서 상속관계로 만들 수 있다.
```java
// 하위 클래스 : MarketRepositoryExtensionImpl
// 상위 클래스 : QuerydslRepositorySupport
public class MarketRepositoryExtensionImpl extends QuerydslRepositorySupport
```
> 상속(Inheritance)이라고 하지만 연장/확장(extends)라고 하는 이유  
> 코드를 재사용하고 추가로 확장의 관점까지 볼 수 있으므로 extends가 좀 더 어울린다. 




### 상속의 단점
객체를 재사용하면서 확장까지 고려할 때 상속은 꽤나 큰 걸림돌이 될 수 있다.
> 즉 상속은 캡슐화를 깨트릴 수 있다.

```java
// 상위 클래스 HashSet
// 하위 클래스 InstrumentedHashSet
public class InstrumentedHashSet<E> extends HashSet<E> {

    private int addCount = 0;

    public InstrumentedHashSet(int initCap, float loadFactor) {
        super(initCap, loadFactor);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```
```java
class InstrumentedHashSetTest {

    @Test
    @DisplayName("상속 테스트")
    void 상속_테스트() {
        InstrumentedHashSet<String> objects = new InstrumentedHashSet<>(1, 2);

        objects.addAll(List.of("가", "나", "다"));

        assertEquals(objects.getAddCount(), 3);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/165884735-08bcbed6-c4a1-4858-93c7-d9dc50868be3.png)
> 3이 출력이 돼야 하지만 6이 반환된다.

#### ❓ 왜 6이 반환된걸까?
	HashSet 클래스의 addAll 메서드가 내부적으로 add를 구현하는데 원인이 있다.  
	addAll에 3개의 원자가 추가 되고 로직 내부에 있는 add를 호출하게 되므로 결국 인자당 2회씩 addAccount가 된것이다.
	
```java
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e)) // add 가 중복으로 일어나게 된다.
                modified = true;
        return modified;
    }
```
> 해결방법 : addAll을 재정의하지 않거나 다른 식의 재정의를 통해 해결을 할 수 있다.

### ✅ 상속보단 컴포지션을 사용해보자.
> 컴포지션 : 기존 클래스를 확장하지 않고, 새로운 클래스를 만든 후, private 필드로 기존 클래스의 인스턴스를 참조하게 하도록 설계하는 방법

#### ❓ 왜 사용하고 어떻게 사용하는걸까?
재정의하는 일이 없어 위의 상속처럼 문제가 될 일이 적어지게 됩니다.

```java
public class CustomHashSetByComposition<E> {
    private final HashSet<E> hashSet;
    private int addCount = 0;

    public CustomHashSetByComposition(HashSet<E> hashSet) {
        this.hashSet = hashSet;
    }

    public boolean add(E e) {
        addCount++;
        return hashSet.add(e);
    }

    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return hashSet.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```
```java
class CustomHashSetByCompositionTest {
    @Test
    @DisplayName("컴포지션 테스트")
    void 컴포지션_테스트() {
        CustomHashSetByComposition<Object> custom = new CustomHashSetByComposition<>(new HashSet<>());

        custom.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7));

        assertEquals(custom.getAddCount(), 7);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/165886563-83fdb31b-a984-4292-92ba-9a890e9c48b6.png)

### 📋 정리
- 상속은 캡슐화를 깨트린다.
- 하위 클래스의 관계가 온전한 is-a 관계일때만 사용해야한다.
- is-a 관계일때도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려하지 않을때 문제가 발생한다.
- 대부분의 경우 컴포지션과 전달을 사용하자. 

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라.
### ❓ 상속을 고려한 설계란?
기능확장 및 재정의를 염두해두고 만드는 상속용 클래스를 말한다.  
즉 재정의할 수 있는 메서드를 내부적으로 `어떻게(how)` 이용하는지 문서로 남겨야한다.

### ✅ 문서 작성 내용
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 `어떻게 사용하는지` 문서로 남겨야한다.
- 호출되는 메서드가 `재정의 가능한 메서드`(public/protected final이 아닌것)라면 그 사실을 호출하는 메서드의 API설명에 명시해야 한다.
- 예시로 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지 등등 `모든 상황`을 문서로 남겨야한다.
- 상속이 캡슐화를 해치기 때문에 해야하는 작업이며, 클래스를 안전하게 상속할 수 있도록 하려면 `내부 구현 방식`을 설명해야 한다.  

### ✅ Hook
> 클래스 내부 동작 과정에서 끼어들 수 있는 훅(hook)을 잘 선별해서 protected 메서드 형태로 공개하는 경우가 있다.  

![스크린샷 2022-04-29 오후 3 26 46 1](https://user-images.githubusercontent.com/53300830/165894851-05b15c74-89ff-4e63-873b-9363f462baac.png)
> removeRange 메서드를 활용하면 clear 메서드의 성능을 향상시킬 수 있기 때문에 List 구현체 문서에 존재하는 것이다.

여기서 중요한점은 접근제한자가 `protected` 인 것이다. 즉 하위 클래스에서 사용할 일이 있다는 것이다.
![스크린샷 2022-04-29 오후 3 38 21](https://user-images.githubusercontent.com/53300830/165895874-d1d06245-1bd6-4b12-ad5f-874f3e480181.png)
> removeRange()가 없는 상태에서 구현할려면 로직을 아예 다시 구현해야 하므로 일을 두 번 하는셈이다. 

추가로 위 스크린샷에서 `@implSpec` 은 자바 9부터 본격적으로 사용한 태그이다. 
[자세한 사용법](https://jaehun2841.github.io/2019/02/24/effective-java-item56/#%EC%97%B4%EA%B1%B0%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EC%83%81%EC%88%98%EB%B3%84%EB%A1%9C-%EC%A3%BC%EC%84%9D%EC%9D%84-%EB%8B%AC%EC%95%84%EB%9D%BC)

### ⛔️ 주의 할 점 1. 상속용 클래스의 생성자가 재정의 가능 메서드를 호출해서는 안된다. 
```java
public class Super {
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
        System.out.println("Super override method!");
    }
}
```
```java
public class Sub extends Super{
    private final Instant instant;
    public Sub() {
        instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println("Sub overrideMe Method!! " + instant);
    }
}
```
![image](https://user-images.githubusercontent.com/53300830/165897668-70983ecf-e04d-4162-b842-d8ff63165872.png)
> sub.overrideMe() 메서드를 한 번 호출한 뒤 생성자에서 instant필드를 초기화만 해줬을 뿐인데 출력이 두번됐으며   
> 첫 번째는 null 값이 나온 것을 알 수 있다.

#### ❓ 왜 위와 같은 결과가 나온걸까?
우선은 상위 클래스의 생성자가 하위 클래스의 생성자보다 항상 먼저 호출된다는 점을 다시 상기시켜야합니다.
1. 부모 클래스의 `Super의 overrideMe()` 메서드가 호출 된다는 것이고
2. 실제적인 `overrideMe()` 는 Sub 클래스이기 때문에 `Sub의 overrideMe()가 호출`이 됩니다.
3. 하지만 여기서 instant가 초기화 즉 명시된 것이 아니기 때문에 instant는 null 값을 가지게 됩니다. 
> 만약 instant에 직접 접근할려고 했다면 NullPointException을 던지게 됩니다. 
> 추가로 private, final, static 메서드는 재정의가 불가능하기에 생성자에서 호출해도 문제가 없습니다.

### ⛔️ 주의 할 점 2. Cloneable, Serializable 인터페이스 구현을 주의하라.
이 두 인터페이스 중 하나라도 구현한 클래스를 상속용 클래스로 설계하게 될 경우 `clone`, `readObject` 모두 직접적으로든 간접적으로든 재정의 메서드를 호출해서는 안된다.
> 즉 클래스를 상속용으로 설계하려면 엄청난 노력이 필요하고 그 클래스에 안기는 제약도 상당하다.

### ⛔️ 주의 할 점 3. 상속용이 아닌 일반 구체 클래스는 상속을 해서는 안된다.
final도 아니고 상속용으로 설계되거나 문서도 없는 일반 클래스를 상속하게되면 클래스가 변경될때마다 확장 클래스들에서 문제가 생길 확률이 높다.
> 클래스를 final로 선언하거나 모든 생성자를 private로 선언해서 정적 팩터리를 만드는게 좋다.

### 📋 결론
- 상속용 클래스를 설계하기란 쉽지 않자. 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야한다.
- 클래스를 확장해야 할 명확한 이유가 없다면 상속을 금지하는 것이 낫다. 
> 클래스를 final로 선언하거나 생성자를 모두 private로 선언해주면 된다.



